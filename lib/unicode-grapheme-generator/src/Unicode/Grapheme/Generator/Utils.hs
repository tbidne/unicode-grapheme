{-# LANGUAGE QuasiQuotes #-}

module Unicode.Grapheme.Generator.Utils
  ( -- * Paths
    mkModulePath,

    -- * Module contents
    writeModule,
    mkModuleHeaderName,
    mkCharSet,
    mkCharMap,

    -- * Misc
    tunlines,
  )
where

import Data.Maybe (fromMaybe)
import Data.Text (Text)
import Data.Text qualified as T
import Data.Text.Encoding qualified as TEnc
import System.File.OsPath qualified as FileIO
import System.OsPath (OsPath, osp, (</>))
import Unicode.Grapheme.Common.DB.GraphemeClusterBreak (GraphemeClusterBreak)
import Unicode.Grapheme.Common.DB.Parsing qualified as Parsing
import Unicode.Grapheme.Common.Version (UnicodeVersion)
import Unicode.Grapheme.Common.Version qualified as Vers

writeModule :: Maybe OsPath -> UnicodeVersion -> Text -> IO ()
writeModule mDir vers contents =
  FileIO.writeFile' path (TEnc.encodeUtf8 $ preamble <> contents)
  where
    defDir =
      [osp|lib|]
        </> [osp|unicode-grapheme|]
        </> [osp|unicode-grapheme-internal|]
        </> [osp|Unicode|]
        </> [osp|Grapheme|]
        </> [osp|Internal|]

    dir = fromMaybe defDir mDir

    path =
      dir
        </> Vers.versToModuleName vers
        </> [osp|DB|]
        </> [osp|Generated.hs|]

    preamble =
      T.unlines
        [ "-- | This module was generated by unicode-grapheme-generator.",
          "-- Please do not exit by hand."
        ]

mkModulePath :: UnicodeVersion -> OsPath
mkModulePath vers =
  [osp|lib|]
    </> [osp|unicode-grapheme|]
    </> [osp|unicode-grapheme-internal|]
    </> [osp|Unicode|]
    </> [osp|Grapheme|]
    </> [osp|Internal|]
    </> Vers.versToModuleName vers
    </> [osp|DB|]
    </> [osp|Generated.hs|]

mkModuleHeaderName :: UnicodeVersion -> Text
mkModuleHeaderName vers =
  T.intercalate
    "."
    [ "Unicode",
      "Grapheme",
      "Internal",
      Vers.displayModuleName vers,
      "DB",
      "Generated"
    ]

mkCharMap :: Text -> [(Char, GraphemeClusterBreak)] -> Text
mkCharMap = mkCharList ty "HMap.fromList" showPair
  where
    ty = "HashMap Char GraphemeClusterBreak"

    showPair (ch, gcb) =
      mconcat
        [ "(",
          cToT ch,
          ", ",
          T.pack $ show gcb,
          ")"
        ]

mkCharSet :: Text -> [Char] -> Text
mkCharSet = mkCharList "HashSet Char" "HSet.fromList" cToT

mkCharList :: Text -> Text -> (a -> Text) -> Text -> [a] -> Text
mkCharList ty cons toText name xs =
  T.unlines
    [ name <> " :: " <> ty,
      name <> start xs
    ]
  where
    start [] = " = " <> cons <> " []"
    start (c : cs) =
      mconcat
        [ " =\n  " <> cons,
          "\n    [ " <> toText c,
          go cs
        ]
    go [] = "\n    ]"
    go (c : cs) =
      mconcat
        [ ",\n      ",
          toText c,
          go cs
        ]

cToT :: Char -> Text
cToT =
  T.pack
    . (\s -> "\'\\x" ++ s <> "'")
    . Parsing.charToHexStringPadN 4

tunlines :: [Text] -> Text
tunlines = T.intercalate "\n"
