{-# LANGUAGE QuasiQuotes #-}

module Unicode.Grapheme.Generator.Utils
  ( -- * Paths
    mkModulePath,

    -- * Module contents
    writeModule,
    mkModuleHeaderName,
    serializeCodePoints,
    serializeCodePointsTuple,

    -- * Misc
    countCodePoints,
    countCodePoint,
    mkImports,
    tunlines,
    unlinesb,
  )
where

import Data.Foldable qualified as F
import Data.List qualified as L
import Data.Maybe (fromMaybe)
import Data.Sequence (Seq (Empty, (:<|)))
import Data.Text (Text)
import Data.Text qualified as T
import Data.Text.Builder.Linear (Builder)
import Data.Text.Builder.Linear qualified as TBLinear
import Data.Text.Encoding qualified as TEnc
import System.File.OsPath qualified as FileIO
import System.OsPath (OsPath, osp, (</>))
import Unicode.Grapheme.Common.DB.Parsing qualified as Parsing
import Unicode.Grapheme.Common.Version (UnicodeVersion)
import Unicode.Grapheme.Common.Version qualified as Vers

writeModule :: Maybe OsPath -> UnicodeVersion -> Text -> IO ()
writeModule mDir vers contents =
  FileIO.writeFile' path (TEnc.encodeUtf8 $ preamble <> contents)
  where
    defDir =
      [osp|lib|]
        </> [osp|unicode-grapheme|]
        </> [osp|unicode-grapheme-internal|]
        </> [osp|Unicode|]
        </> [osp|Grapheme|]
        </> [osp|Internal|]

    dir = fromMaybe defDir mDir

    path =
      dir
        </> Vers.versToModuleName vers
        </> [osp|DB|]
        </> [osp|Generated.hs|]

    preamble =
      T.unlines
        [ "-- | This module was generated by unicode-grapheme-generator.",
          "-- Please do not exit by hand."
        ]

mkModulePath :: UnicodeVersion -> OsPath
mkModulePath vers =
  [osp|lib|]
    </> [osp|unicode-grapheme|]
    </> [osp|unicode-grapheme-internal|]
    </> [osp|Unicode|]
    </> [osp|Grapheme|]
    </> [osp|Internal|]
    </> Vers.versToModuleName vers
    </> [osp|DB|]
    </> [osp|Generated.hs|]

mkModuleHeaderName :: UnicodeVersion -> Builder
mkModuleHeaderName vers =
  mconcat
    [ "Unicode.Grapheme.Internal.",
      stringToBuilder $ Vers.displayModuleName vers,
      ".DB.Generated"
    ]

serializeCodePoints :: Builder -> Seq (Char, Maybe Char) -> Builder
serializeCodePoints name =
  serializeList
    toText
    name
    "(Char, Maybe Char)"
  where
    toText (c, mD) =
      mconcat
        [ "(",
          cToT c,
          ", ",
          mToText mD,
          ")"
        ]

-- | Serializes a tuple.
serializeCodePointsTuple ::
  (Show a) =>
  -- | Function name.
  Builder ->
  -- | Type name.
  Builder ->
  -- | Sequence.
  Seq (Char, Maybe Char, a) ->
  Builder
serializeCodePointsTuple fnName tyName =
  serializeList
    toText
    fnName
    ("(Char, Maybe Char, " <> tyName <> ")")
  where
    toText (c, mD, x) =
      mconcat
        [ "(",
          cToT c,
          ", ",
          mToText mD,
          ", ",
          showb x,
          ")"
        ]

serializeList ::
  -- | Text display function.
  (a -> Builder) ->
  -- | Function name.
  Builder ->
  -- | Type name.
  Builder ->
  -- | Sequence to serialize.
  Seq a ->
  Builder
serializeList toText fnName tyName xs =
  mconcat
    [ fnName <> " :: [" <> tyName <> "]\n",
      fnName <> " =" <> start xs,
      "\n"
    ]
  where
    start Empty = " []"
    start (c :<| cs) =
      mconcat
        [ "\n  [ ",
          toText c,
          go cs
        ]

    go Empty = "\n  ]"
    go (c :<| cs) =
      mconcat
        [ ",\n    ",
          toText c,
          go cs
        ]

mToText :: Maybe Char -> Builder
mToText Nothing = "Nothing"
mToText (Just c) = "Just " <> cToT c

cToT :: Char -> Builder
cToT =
  (\s -> "\'\\x" <> s <> "'")
    . stringToBuilder
    . Parsing.charToHexStringPadN 4

tunlines :: [Text] -> Text
tunlines = T.intercalate "\n"

countCodePoints :: Seq (Char, Maybe Char) -> Int
countCodePoints = F.foldl' go 0
  where
    go !acc c = acc + countCodePoint c

countCodePoint :: (Char, Maybe Char) -> Int
countCodePoint (_, Nothing) = 1
countCodePoint (c, Just d) = length [c .. d]

showb :: (Show a) => a -> Builder
showb = stringToBuilder . show

stringToBuilder :: [Char] -> Builder
stringToBuilder = mconcat . fmap TBLinear.fromChar

mkImports :: Builder
mkImports =
  unlinesb
    [ "import Unicode.Grapheme.Common.DB.GraphemeClusterBreak",
      "  ( GraphemeClusterBreak",
      "      ( GraphemeClusterBreak_CR,",
      "        GraphemeClusterBreak_Control,",
      "        GraphemeClusterBreak_Extend,",
      "        GraphemeClusterBreak_L,",
      "        GraphemeClusterBreak_LF,",
      "        GraphemeClusterBreak_LV,",
      "        GraphemeClusterBreak_LVT,",
      "        GraphemeClusterBreak_Prepend,",
      "        GraphemeClusterBreak_Regional_Indicator,",
      "        GraphemeClusterBreak_SpacingMark,",
      "        GraphemeClusterBreak_T,",
      "        GraphemeClusterBreak_V,",
      "        GraphemeClusterBreak_ZWJ",
      "      ),",
      "  )\n"
    ]

unlinesb :: [Builder] -> Builder
unlinesb = mconcat . L.intersperse "\n"
