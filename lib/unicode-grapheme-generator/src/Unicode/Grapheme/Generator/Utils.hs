{-# LANGUAGE QuasiQuotes #-}

module Unicode.Grapheme.Generator.Utils
  ( -- * Paths
    mkModulePath,

    -- * Module contents
    writeModule,
    mkModuleHeaderName,
    mkCharSet,
    mkCharMap,
    serializeCodePoints,
    serializeCodePointsTuple,

    -- * Misc
    countCodePoints,
    countCodePoint,
    tunlines,
  )
where

import Data.Foldable qualified as F
import Data.Maybe (fromMaybe)
import Data.Sequence (Seq (Empty, (:<|)))
import Data.Text (Text)
import Data.Text qualified as T
import Data.Text.Encoding qualified as TEnc
import System.File.OsPath qualified as FileIO
import System.OsPath (OsPath, osp, (</>))
import Unicode.Grapheme.Common.DB.GraphemeClusterBreak (GraphemeClusterBreak)
import Unicode.Grapheme.Common.DB.Parsing qualified as Parsing
import Unicode.Grapheme.Common.Version (UnicodeVersion)
import Unicode.Grapheme.Common.Version qualified as Vers

writeModule :: Maybe OsPath -> UnicodeVersion -> Text -> IO ()
writeModule mDir vers contents =
  FileIO.writeFile' path (TEnc.encodeUtf8 $ preamble <> contents)
  where
    defDir =
      [osp|lib|]
        </> [osp|unicode-grapheme|]
        </> [osp|unicode-grapheme-internal|]
        </> [osp|Unicode|]
        </> [osp|Grapheme|]
        </> [osp|Internal|]

    dir = fromMaybe defDir mDir

    path =
      dir
        </> Vers.versToModuleName vers
        </> [osp|DB|]
        </> [osp|Generated.hs|]

    preamble =
      T.unlines
        [ "-- | This module was generated by unicode-grapheme-generator.",
          "-- Please do not exit by hand."
        ]

mkModulePath :: UnicodeVersion -> OsPath
mkModulePath vers =
  [osp|lib|]
    </> [osp|unicode-grapheme|]
    </> [osp|unicode-grapheme-internal|]
    </> [osp|Unicode|]
    </> [osp|Grapheme|]
    </> [osp|Internal|]
    </> Vers.versToModuleName vers
    </> [osp|DB|]
    </> [osp|Generated.hs|]

mkModuleHeaderName :: UnicodeVersion -> Text
mkModuleHeaderName vers =
  T.intercalate
    "."
    [ "Unicode",
      "Grapheme",
      "Internal",
      Vers.displayModuleName vers,
      "DB",
      "Generated"
    ]

mkCharMap :: Text -> [(Char, GraphemeClusterBreak)] -> Text
mkCharMap = mkCharList ty "HMap.fromList" showPair
  where
    ty = "HashMap Char GraphemeClusterBreak"

    showPair (ch, gcb) =
      mconcat
        [ "(",
          cToT ch,
          ", ",
          T.pack $ show gcb,
          ")"
        ]

mkCharSet :: Text -> [Char] -> Text
mkCharSet = mkCharList "HashSet Char" "HSet.fromList" cToT

mkCharList :: Text -> Text -> (a -> Text) -> Text -> [a] -> Text
mkCharList ty cons toText name xs =
  T.unlines
    [ name <> " :: " <> ty,
      name <> start xs
    ]
  where
    start [] = " = " <> cons <> " []"
    start (c : cs) =
      mconcat
        [ " =\n  " <> cons,
          "\n    [ " <> toText c,
          go cs
        ]
    go [] = "\n    ]"
    go (c : cs) =
      mconcat
        [ ",\n      ",
          toText c,
          go cs
        ]

serializeCodePoints :: Text -> Seq (Char, Maybe Char) -> Text
serializeCodePoints name =
  serializeList
    toText
    name
    "(Char, Maybe Char)"
  where
    -- TODO: Benchmark against builder or text-builder-linear
    toText (c, mD) =
      "("
        <> cToT c
        <> ", "
        <> mToText mD
        <> ")"

-- | Serializes a tuple.
serializeCodePointsTuple ::
  (Show a) =>
  -- | Function name.
  Text ->
  -- | Type name.
  Text ->
  -- | Sequence.
  Seq (Char, Maybe Char, a) ->
  Text
serializeCodePointsTuple fnName tyName =
  serializeList
    toText
    fnName
    ("(Char, Maybe Char, " <> tyName <> ")")
  where
    -- TODO: Benchmark against builder or text-builder-linear
    toText (c, mD, x) =
      "("
        <> cToT c
        <> ", "
        <> mToText mD
        <> ", "
        <> showt x
        <> ")"

serializeList ::
  -- | Text display function.
  (a -> Text) ->
  -- | Function name.
  Text ->
  -- | Type name.
  Text ->
  -- | Sequence to serialize.
  Seq a ->
  Text
serializeList toText fnName tyName xs =
  T.unlines
    [ fnName <> " :: [" <> tyName <> "]",
      fnName <> " =" <> start xs
    ]
  where
    start Empty = " []"
    start (c :<| cs) =
      mconcat
        [ "\n  [ ",
          toText c,
          go cs
        ]

    go Empty = "\n  ]"
    go (c :<| cs) =
      mconcat
        [ ",\n    ",
          toText c,
          go cs
        ]

mToText :: Maybe Char -> Text
mToText Nothing = "Nothing"
mToText (Just c) = "Just " <> cToT c

cToT :: Char -> Text
cToT =
  T.pack
    . (\s -> "\'\\x" ++ s <> "'")
    . Parsing.charToHexStringPadN 4

tunlines :: [Text] -> Text
tunlines = T.intercalate "\n"

countCodePoints :: Seq (Char, Maybe Char) -> Int
countCodePoints = F.foldl' go 0
  where
    go !acc c = acc + countCodePoint c

countCodePoint :: (Char, Maybe Char) -> Int
countCodePoint (_, Nothing) = 1
countCodePoint (c, Just d) = length [c .. d]

showt :: (Show a) => a -> Text
showt = T.pack . show
