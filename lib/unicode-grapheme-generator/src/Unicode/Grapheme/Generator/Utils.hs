{-# LANGUAGE QuasiQuotes #-}

module Unicode.Grapheme.Generator.Utils
  ( -- * Paths
    mkModulePath,
    mkUnicodePath,

    -- * Module contents
    writeModule,
    mkModuleHeaderName,
    serializeCodePoints,
    serializeCodePointsTuple,

    -- * Parsing
    PropParser,
    parseProps,
    PropertyAssertionE (..),

    -- * Misc
    countCodePoints,
    countCodePoint,
    mkImports,
    tunlines,
    unlinesb,
  )
where

import Control.Applicative (Alternative ((<|>)))
import Control.Exception (Exception)
import Data.Bifunctor (Bifunctor (first))
import Data.ByteString (ByteString)
import Data.ByteString.Char8 qualified as C8
import Data.Char qualified as Ch
import Data.Foldable qualified as F
import Data.List qualified as L
import Data.Maybe (fromMaybe)
import Data.Sequence (Seq (Empty, (:<|)))
import Data.Text (Text)
import Data.Text qualified as T
import Data.Text.Builder.Linear (Builder)
import Data.Text.Builder.Linear qualified as TBLinear
import Data.Text.Encoding qualified as TEnc
import GHC.Exception.Type (Exception (displayException))
import System.File.OsPath qualified as FileIO
import System.OsPath (OsPath, osp, (</>))
import Unicode.Grapheme.Generator.DB.Parsing qualified as Parsing
import Unicode.Grapheme.Generator.Version (UnicodeVersion)
import Unicode.Grapheme.Generator.Version qualified as Vers
import Unicode.Grapheme.Generator.Version qualified as Version

mkUnicodePath :: Maybe OsPath -> UnicodeVersion -> OsPath -> OsPath
mkUnicodePath mdir uvers p =
  dir
    </> Vers.versToFolderName uvers
    </> p
  where
    dir = fromMaybe [osp|data|] mdir

writeModule :: Maybe OsPath -> UnicodeVersion -> Text -> IO ()
writeModule mDir vers contents =
  FileIO.writeFile' path (TEnc.encodeUtf8 $ preamble <> contents)
  where
    defDir =
      [osp|lib|]
        </> [osp|unicode-grapheme|]
        </> [osp|unicode-grapheme-internal|]
        </> [osp|Unicode|]
        </> [osp|Grapheme|]
        </> [osp|Internal|]

    dir = fromMaybe defDir mDir

    path =
      dir
        </> Vers.versToModuleName vers
        </> [osp|DB|]
        </> [osp|Generated.hs|]

    preamble =
      T.unlines
        [ "-- | This module was generated by unicode-grapheme-generator.",
          "-- Please do not edit by hand."
        ]

mkModulePath :: UnicodeVersion -> OsPath
mkModulePath vers =
  [osp|lib|]
    </> [osp|unicode-grapheme|]
    </> [osp|unicode-grapheme-internal|]
    </> [osp|Unicode|]
    </> [osp|Grapheme|]
    </> [osp|Internal|]
    </> Vers.versToModuleName vers
    </> [osp|DB|]
    </> [osp|Generated.hs|]

mkModuleHeaderName :: UnicodeVersion -> Builder
mkModuleHeaderName vers =
  mconcat
    [ "Unicode.Grapheme.Internal.",
      stringToBuilder $ Vers.displayModuleName vers,
      ".DB.Generated"
    ]

serializeCodePoints :: Builder -> Seq (Char, Maybe Char) -> Builder
serializeCodePoints name =
  serializeList
    toText
    name
    "(Char, Maybe Char)"
  where
    toText (c, mD) =
      mconcat
        [ "(",
          cToT c,
          ", ",
          mToText mD,
          ")"
        ]

-- | Serializes a tuple.
serializeCodePointsTuple ::
  (Show a) =>
  -- | Function name.
  Builder ->
  -- | Type name.
  Builder ->
  -- | Sequence.
  Seq (Char, Maybe Char, a) ->
  Builder
serializeCodePointsTuple fnName tyName =
  serializeList
    toText
    fnName
    ("(Char, Maybe Char, " <> tyName <> ")")
  where
    toText (c, mD, x) =
      mconcat
        [ "(",
          cToT c,
          ", ",
          mToText mD,
          ", ",
          showb x,
          ")"
        ]

serializeList ::
  -- | Text display function.
  (a -> Builder) ->
  -- | Function name.
  Builder ->
  -- | Type name.
  Builder ->
  -- | Sequence to serialize.
  Seq a ->
  Builder
serializeList toText fnName tyName xs =
  mconcat
    [ fnName <> " :: [" <> tyName <> "]\n",
      fnName <> " =" <> start xs,
      "\n"
    ]
  where
    start Empty = " []"
    start (c :<| cs) =
      mconcat
        [ "\n  [ ",
          toText c,
          go cs
        ]

    go Empty = "\n  ]"
    go (c :<| cs) =
      mconcat
        [ ",\n    ",
          toText c,
          go cs
        ]

mToText :: Maybe Char -> Builder
mToText Nothing = "Nothing"
mToText (Just c) = "Just " <> cToT c

cToT :: Char -> Builder
cToT =
  (\s -> "\'\\x" <> s <> "'")
    . stringToBuilder
    . Parsing.charToHexStringPad4

tunlines :: [Text] -> Text
tunlines = T.intercalate "\n"

countCodePoints :: Seq (Char, Maybe Char) -> Int
countCodePoints = F.foldl' go 0
  where
    go !acc c = acc + countCodePoint c

countCodePoint :: (Char, Maybe Char) -> Int
countCodePoint (_, Nothing) = 1
countCodePoint (c, Just d) = Ch.ord d - Ch.ord c + 1

showb :: (Show a) => a -> Builder
showb = stringToBuilder . show

stringToBuilder :: [Char] -> Builder
stringToBuilder = mconcat . fmap TBLinear.fromChar

mkImports :: Builder
mkImports =
  unlinesb
    [ "import Unicode.Grapheme.Internal.DB.GraphemeClusterBreak",
      "  ( GraphemeClusterBreak",
      "      ( GraphemeClusterBreak_CR,",
      "        GraphemeClusterBreak_Control,",
      "        GraphemeClusterBreak_Extend,",
      "        GraphemeClusterBreak_L,",
      "        GraphemeClusterBreak_LF,",
      "        GraphemeClusterBreak_LV,",
      "        GraphemeClusterBreak_LVT,",
      "        GraphemeClusterBreak_Prepend,",
      "        GraphemeClusterBreak_Regional_Indicator,",
      "        GraphemeClusterBreak_SpacingMark,",
      "        GraphemeClusterBreak_T,",
      "        GraphemeClusterBreak_V,",
      "        GraphemeClusterBreak_ZWJ",
      "      ),",
      "  )\n"
    ]

unlinesb :: [Builder] -> Builder
unlinesb = mconcat . L.intersperse "\n"

parseProps ::
  [PropParser prop] ->
  (props -> (prop, Char, Maybe Char) -> props) ->
  props ->
  ByteString ->
  props
parseProps propParser onProp initAcc = F.foldl' go initAcc . C8.lines
  where
    go = lineToProps propParser onProp

lineToProps ::
  [PropParser prop] ->
  (props -> (prop, Char, Maybe Char) -> props) ->
  props ->
  ByteString ->
  props
lineToProps propParsers onProp acc bs = case bsToProp propParsers bs of
  Nothing -> acc
  Just result -> onProp acc result

type PropParser prop = ByteString -> Maybe (prop, ByteString)

bsToProp :: [PropParser prop] -> ByteString -> Maybe (prop, Char, Maybe Char)
bsToProp propParsers bs = do
  (c1, mC2, r1) <-
    first Just <$> Parsing.parseCodePointRange bs
      <|> (\(c, b) -> (c, Nothing, b)) <$> Parsing.parseCodePoint bs

  r2 <- Parsing.parseSemiColon r1

  (prop, _) <- Parsing.parseFirst propParsers r2

  pure (prop, c1, mC2)

-- | Exception for when an expectation number of code points with a certain
-- property does not match the actual result.
data PropertyAssertionE = MkPropertyAssertionE
  { -- | Actual number of parsed code points.
    actual :: Int,
    -- | Expected number of code points.
    expected :: Int,
    -- | Property type name e.g. Derived_Core_Property
    propTypeName :: String,
    -- | Property type value e.g. Indic_Conjunct_Break_Consonant
    propValue :: String,
    -- | Unicode version.
    version :: UnicodeVersion
  }
  deriving stock (Eq, Show)

instance Exception PropertyAssertionE where
  displayException ex =
    mconcat
      [ "Unicode ",
        T.unpack (Version.displayVersion ex.version),
        ": ",
        ex.propTypeName,
        " assertion '",
        ex.propValue,
        "' failure. Expected ",
        show ex.expected,
        ", received ",
        show ex.actual,
        "."
      ]
